## 简答

#### 1. 简述 Node.js 的特点以及适用的场景
特点：
- 异步`IO`：
  - `IO`是计算机操作过程中最缓慢的环节（`ms`级别）。
  - `nodeJS`采用应答模式，单线程完成多线程工作（类比餐馆点餐，非阻塞）。
  - 异步`IO`提高性能，无须原地等待结果返回。`IO`操作属于操作系统级别，各平台都有对应的实现。
  - `NodeJS`单线程配合事件驱动以及`libuv`实现了异步`IO`
- 事件驱动
  - 事件驱动是软件开发中的通用模式，主体发布消息，其他实例接收消息。

架构：由内置的核心模块(如：`fs`、`path`、`http`等)、`V8`引擎辅助的”胶水层“、`V8`引擎底层的`Libuv`库

适用场景：
- 轻量级、高性能的`Web`服务
- 前后端`JavaScript`同构开发，可以作为中间层处理客户端`http`请求、格式化数据、渲染`html`页面、合并请求页面、解决跨域、数据缓存。
- 便捷高效的前端工程化
- `NodeJS`更适用于`IO`密集型高并发请求，异步`IO`提高了`CPU`的使用率。
　
#### 2. 简述 Buffer 的使用.包括多种创建方式。实例方法，静态方法
`Buffer`的作用：
- `Buffer`让`JavaScript`可以操作二进制，`IO`行为操作的就是二进制数据。流操作配合管道就可以实现数据的分段传输，`Buffer`本质是一片内存空间。
`Buffer`的使用：
- 创建`Buffer`
  - `alloc`: 创建指定字节大小的`Buffer`，如：``` const b1 = Buffer.alloc(10) ```
  - `allocUnsafe`: 创建指定字节大小的`Buffer`(不安全：会使用携带数据的无用的内存空间)，如：``` const b2 = Buffer.allocUnsafe(10) ```
  - `from`:接收数据，创建`Buffer`，如：``` const b2 = Buffer.from('1', 'utf-8') ```
- `Buffer`实例方法
  - `fill`: 使用数据填充`buffer`，若填入字段不能占满空间会重复写入。
  - `write`: 向`buffer`中写入数据，可以通过参数指定写入内存空间位置。
  - `toString`: 从`buffer`中提取数据，指定编码方式后，获取转义后字符。
  - `slice`: 截取`buffer`，可以指定截取的内存空间位置。
  - `indexOf`: 在`buffer`中查找数据
  - `copy`: 拷贝`buffer`中的数据
- `Buffer`静态方法
  - `concat`: 将多个`buffer`拼接成一个新的`buffer`
  - `isBuffer`: 判断当前数据是否是`buffer`
　
#### 3. 写出5个以上文件操作的API，并且用文字说明其功能
文件操作的`API`：
- `readFile`（异步方法）: 从指定文件中以某种编码格式读取数据，存在回调函数（错误优先）可以获取文件内容
- `writeFile`（异步方法）: 向指定文件中写入数据（默认覆盖原有数据），存在回调函数（错误优先）可以获取写入内容。若指定文件不存在，会执行创建文件操作。
  可以通过配置第三个参数指定自定义的操作模式。
- `appendFile`（异步方法）: 以追加的方式以某种编码格式，向指定文件中写入数据
- `copyFile`（异步方法）: 将某个二文件中的数据拷贝到另一个文件中，不适合大数据文件的复制
- `watchFile`（异步方法）: 对指定文件进行监控，可以指定监控的循环的频率。可以通过`unwatchFile`取消对指定文件的监控。

#### 4. 简述使用流操作的优势，以及Node中流的分类
`nodeJS`中的流的概念及模块：
- 流是处理流式数据的抽象接口
- 文件操作系统（`fs`）和网络模块实现了流接口
流操作的优势（解决同步读数据，用户需等待读取完成，以及资源文件一次性加载到内存，开销大等问题）：
- 时间效率：流的分段处理可以同时操作多个数据`chunk`
- 空间效率：同一时间流无须占据内存空间
- 使用方便：流配合管理，扩展程序变的简单
`NodeJS`中流的分类：
- `NodeJS`内置了stream，它实现了流操作对象
- `Readable`: 可读流，能实现数据的读取。如：```let rs = fs.createReadStream('./test.txt')```
- `Writeable`: 可写流，能实现数据的写操作。如：```let ws = fs.createWriteStream('./test1.txt')```
- `Duplex`: 双工流，既可读又可写
- `Tranform`: 转换流，可读可写，还能实现数据的转换
所有的流都继承自`EventEmitter`,可读流用于生产消费数据的流。数据的消费存在流动模式和暂停模式两种。
当流中存在可读数据时触发`readable`事件。当流中的数据块传给消费者后触发`data`事件。
#### 5. 在数据封装与解封装过程中，针对应用层、传输层、网络层、数据链路层、物理层5层分别做了什么事情？
应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。邮件、http、域名。原始数据（应用层数据）
- 封装：将数据封装在对应的应用层协议数据体中，添加应用层协议的协议头，如HTTP协议的请求头和请求体（数据通常封装在请求体）
- 解封：通过协议规范，将协议头和数据体拆分，数据从协议数据体中提取
传输层：为进程提供通用数据传输服务。目标端口 + 源端口 + 原始数据
- 封装：将应用层数据报封装在数据包的数据体中，添加传输层协议头，如TCP首部
- 解封：将协议头和数据体拆分，根据协议头的信息来将数据体交给应用层来处理
网络层：为主机提供数据传输服务。目标IP + 源IP + 目标端口 + 源端口 + 原始数据
- 封装：将传输层的数据报封装在网络层的数据体中，添加网络层协议头，如IP首部
- 解封：将协议头和数据体拆分，根据协议头的信息来将数据体交给传输层来处理
数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。
目标Mac + 源Mac + 目标IP + 源IP + 目标端口 + 源端口 + 原始数据
- 封装：将网络层的数据报封装在数据链路层的数据体中，添加数据链路层协议头，如MAC地址等信息
- 解封：将协议头和数据体拆分，根据协议头的信息来将数据体交给网络层来处理
物理层：物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。转换成二进制数据表示的高低电压
- 封装：物理层负责将数字信号转换为电信号发送
- 解封：物理层负责将接收的电信号转换为数字信号

## 代码题

#### 1. 统计指定目录中文件总大小。要考虑目录中还有子目录的情况。可以同步编码,异步更好
参见本级目录`code\01-file-Size`

#### 2. 编写单向链表类并且实现队列的入列出列操作
参见本级目录`code\02-link-list`

#### 3. 基于Node写出一静态服务器。接收请求并且响应特定目录(服务器目录)中的html、css、js、图片等资源
参见本级目录`code\03-web-serve`


　

　
